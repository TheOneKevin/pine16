=== OPCODE ENCODING ===
Can be 1, 2, 3 or 4 bytes long
oooo_ootu sssd_ddvb iiii_iiii iiii_iiii

+= LEGEND =+
o opcode (64 * u = 128 effective instructions)
u load next byte
v load next byte
t addressing mode
b byte/word operation
i immediate value
+==========+

Notes:
if v & b then load next 2 bytes
if u | t then load next byte
if t     then mode = memory

Addressing Modes:
uvt mnemonic
100 rs <- rd
110 rs <- imm8/16
001 rs <- [rd]
011 rs <- [imm16]
111 rs <- [rd+imm16]
000 invalid
010 impossible
101 Same as 001

Reverse Modes (store):
uvt mnemonic
101 [rs] <- rd
111 [imm16] <- rd
111 [rs+imm16] <- rd

+==== INSTRUCTION SET ====+

== BLOCK 0000_xx_1x to 1011_xx_1x ==

MOV  0000_sd_1t sssd_ddvb (imm) * Note: MOV as memory load operation
ADD  0001_sd_1t sssd_ddvb (imm)
SUB  0010_sd_1t sssd_ddvb (imm)
MUL  0011_sd_1t sssd_ddvb (imm)
AND  0100_sd_1t sssd_ddvb (imm)
OR   0101_sd_1t sssd_ddvb (imm)
XOR  0110_sd_1t sssd_ddvb (imm)
SHL  0111_sd_1t sssd_ddvb (imm)
SHR  1000_sd_1t sssd_ddvb (imm)
ROL  1001_sd_1t sssd_ddvb (imm)
ROR  1010_sd_1t sssd_ddvb (imm)
CMP  1011_sd_1t sssd_ddvb (imm)

== BLOCK 1100_0x_1x (special) ==

MOV  1100_0d_1s sssd_ddvb (imm) * Note: MOV as memory store operation

== BLOCK 1101_00_00 to 1101_10_00 ==

NOP  1101_00_00
RET  1101_01_00
RETI 1101_10_00

== BLOCK 1101_11_10 ==

INT  1101_11_10 imm8

== BLOCK 1110_00_10 xxxx_xx10 ==

INB  1110_00_10 00dd_dd10 imm8
OUTB 1110_00_10 01dd_dd10 imm8
INW  1110_00_10 10dd_dd10 imm8
OUTW 1110_00_10 11dd_dd10 imm8

== BLOCK 1110_01_11 xxxx_xx0b ==

NOT  1110_01_11 00dd_dd0b

== BLOCK 1110_10_00 and 1110_11_00 ==

CLI  1110_10_00
STI  1110_11_00

== BLOCK 1111_00_1x ==

JMP  1111_00_1t 000d_ddv0 (imm)
JE   1111_00_1t 001d_ddv0 (imm)
JNE  1111_00_1t 010d_ddv0 (imm)
JG   1111_00_1t 011d_ddv0 (imm)
JL   1111_00_1t 100d_ddv0 (imm)
JGE  1111_00_1t 101d_ddv0 (imm)
JLE  1111_00_1t 110d_ddv0 (imm)
CALL 1111_00_1t 111d_ddv0 (imm)
